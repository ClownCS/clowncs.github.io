---
weight: 1
title: "TetCTF 2024"
date: 2024-01-30T14:30:00+07:00
lastmod: 2024-01-30T14:30:00+07:00
draft: false
author: "ClownCS"
authorLink: "https://clowncs.github.io"
description: "Solutions for some reverse challenges in TetCTF"
tags: ["RE", "TetCTF","2024"]
categories: ["Writeups"]

lightgallery: true

toc:
  enable: true
---
Solutions for some reverse challenges in TetCTF

<!--more-->

Giải TetCTF là một giải CTF do người Việt đứng ra tổ chức với mức rate khá cao gần ~80. Thoạt đầu mình nghĩ sẽ không có cơ hội giải được. Tuy nhiên vì tết ở quê quá chán vẫn phải ngồi try hard và may mắn solve được hai câu.

![image](https://github.com/ClownCS/clowncs.github.io/assets/90112096/288c7969-6b26-440b-ab5d-d3dc1ca8d426)


# RE
Mình xin phép được để solution bài thứ 2, bởi bài thứ 1 khá là dễ.

## Warm up
Như cái tên của nó chỉ là một bài warm up. Nhận input và kiểm tra điều kiện nếu đúng trả về flag.

```C
__int64 __fastcall check_key(const char *a1)
{
  __int64 v2; // rbx
  unsigned int i; // [rsp+18h] [rbp-258h]
  unsigned int j; // [rsp+1Ch] [rbp-254h]
  unsigned int k; // [rsp+20h] [rbp-250h]
  unsigned int m; // [rsp+24h] [rbp-24Ch]
  unsigned int n; // [rsp+28h] [rbp-248h]
  unsigned int ii; // [rsp+2Ch] [rbp-244h]
  __int64 v9[22]; // [rsp+30h] [rbp-240h] BYREF
  __int64 v10[22]; // [rsp+E0h] [rbp-190h] BYREF
  __int64 v11[22]; // [rsp+190h] [rbp-E0h]
  char v12[24]; // [rsp+240h] [rbp-30h] BYREF
  unsigned __int64 v13; // [rsp+258h] [rbp-18h]

  v13 = __readfsqword(0x28u);
  if ( strlen(a1) != 84 )
    return 0LL;
  strcpy(v12, "!_acdefghilmnoprstuwy");
  for ( i = 0; i <= 0x53; ++i )
  {
    for ( j = 0; j <= 0x14 && v12[j] != a1[i]; ++j )
    {
      if ( j == 20 )
        return 0LL;
    }
  }
  memset(v9, 0, 0xA8uLL);
  for ( k = 0; k <= 0x14; ++k )
    v9[k] = (int)hash_64_fnv1a(&a1[4 * k], 4LL);
  x = 123456789;
  y = 362436069;
  z = 521288629;
  w = -559038737;
  memset(v10, 0, 0xA8uLL);
  for ( m = 0; m <= 0x14; ++m )
  {
    for ( n = 0; n <= 0x14; ++n )
    {
      v2 = v9[n];
      v10[m] += (int)xorshift128() % 1024 * v2;
    }
  }
  v11[0] = 0xFFFFFF6F11B8034BLL;
  v11[1] = 0x673420DAF2LL;
  v11[2] = 0x45EB817F02CLL;
  v11[3] = 0xFFFFFE3099503945LL;
  v11[4] = 0x18F8DCE1227LL;
  v11[5] = 0x26050EA6875LL;
  v11[6] = 0x298599C4BF0LL;
  v11[7] = 0xFFFFF8A356CE9E58LL;
  v11[8] = 0xFFFFFED3C712CF36LL;
  v11[9] = 0xFFFFFE96846D630FLL;
  v11[10] = 0x58CB1CE3FF3LL;
  v11[11] = 0xFFFFFCCF182C2A63LL;
  v11[12] = 0xFFFFFE57FDF3F1DELL;
  v11[13] = 0xFFFFFA603F35F962LL;
  v11[14] = 0xFFFFFF7884570B57LL;
  v11[15] = 0x4897C4D9C1LL;
  v11[16] = 0xFFFFFEB9355E5CB4LL;
  v11[17] = 0xDCEDF7D094LL;
  v11[18] = 0x3602E9CAC47LL;
  v11[19] = 0xFFFFFEE3667219D6LL;
  v11[20] = 0xFFFFFDC326C9B063LL;
  for ( ii = 0; ii <= 0x14; ++ii )
  {
    if ( v11[ii] != v10[ii] )
      return 0LL;
  }
  return 1LL;
}
```
Đọc sơ qua chương trình ta có những gì thứ nhất ``a1`` tức flag có độ dài phải là 84 và các kí tự của nó phải được cấu từ những kí tự của chuỗi ``!_acdefghilmnoprstuwy``. Sau đó nó thực hiện hash 4 bytes một của flag cuối cùng là xorshift128(). Vậy flow chương trình đọc rất dễ code rất clean. Vậy chỗ khó mà tác giả muốn gửi gắm ở đâu. Đó là việc gây khó khăn trong việc kiểu dữ liệu bị chuyển đổi liên tục từ 32 bit -> 64 bit và ngược lại cái này chỉ cần debug thì ta có thể implement nó một cách dễ dàng. Mình thực hiện implement lại qua code này

```python
import ctypes

def sign_extend_32_to_64(value):
    if value & (1 << 31):
        extended_value = value | (0xffffffff << 32)
    else:
        extended_value = value
    return extended_value

def unsign_extend_64_to_32(value):
    lower_32_bits = value & 0xffffffff
    return lower_32_bits


def hash_64_fnv1a(a1, size):
    ulong_var = ctypes.c_ulong(0xCBF29CE484222325)
    for i in range(size, size + 4, 1):
        ulong_var.value = 0x100000001B3 * (a1[i] ^ ulong_var.value)
    tmp = ulong_var.value
    extended_value = unsign_extend_64_to_32(tmp)
    final = sign_extend_32_to_64(extended_value)
    return final

def xorshift128():
    x = 0x75BCD15
    y = 0x159A55E5
    z = 0x1F123BB5
    w = 0xDEADBEEF

    def _random():
        nonlocal x, y, z, w
        t = x ^ ((x << 11) & 0xFFFFFFFF)  
        x, y, z = y, z, w
        w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))
        return w
    
    return _random

a1 = b"acdefghilmnoprstuwyacdefghilmnoprstuwyacdefghilmnoprstuwyacdefghilmnoprstuwyacdefghi"
v9 = [0] * 21
for i in range(21):
    v9[i] = (hash_64_fnv1a(a1, 4 * i))


v10 = [0] * 22

shr_sar = [0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x0, 0x0, 0x3ff, 0x0, 0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x0, 0x0, 0x0, 0x0, 0x3ff, 0x0, 0x0, 0x0, 0x3ff, 0x0, 0x0, 0x0, 0x3ff, 0x0, 0x3ff, 0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x0, 0x0, 0x0, 0x3ff, 0x0, 0x0, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x0, 0x0, 0x0, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x0, 0x3ff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3ff, 0x0, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x0, 0x3ff, 0x0, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x0, 0x0, 0x0, 0x3ff, 0x0, 0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x0, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x0, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x0, 0x0, 0x3ff, 0x3ff, 0x0, 0x0, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x0, 0x0, 0x0, 0x3ff, 0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x0, 0x0, 0x0, 0x0, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x0, 0x3ff, 0x0, 0x3ff, 0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x0, 0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x0, 0x0, 0x3ff, 0x0, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x0, 0x3ff, 0x0, 0x0, 0x3ff, 0x0, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x0, 0x3ff, 0x0, 0x0, 0x0, 0x0, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x0, 0x0, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x0]

cnt = 0
r = xorshift128()
for i in range(21):
    value_after = ctypes.c_ulong(0)
    for j in range(21):
        random_value = int(r()) 
        tmp = random_value
        final = ctypes.c_ulong()
        final.value = (((tmp + shr_sar[cnt])  % 1024) - shr_sar[cnt])
        cnt+=1
        final.value *= v9[j]
        value_after.value += final.value
    v10[i] = value_after.value
    print(hex(value_after.value))
```

Implement lại thành công thế thì tiếp theo việc ta cần là recover lại được mảng v9 sau khi hash bằng cách dùng z3 sau đó bruteforce để nó nhả về đúng flag. Code z3 để tìm v9:
```python
from z3 import *
import ctypes

def xorshift128():
    x = 0x75BCD15
    y = 0x159A55E5
    z = 0x1F123BB5
    w = 0xDEADBEEF

    def _random():
        nonlocal x, y, z, w
        t = x ^ ((x << 11) & 0xFFFFFFFF)  
        x, y, z = y, z, w
        w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))
        return w
    
    return _random


s = Solver()

v11 = [
    0xFFFFFF6F11B8034B, 0x673420DAF2, 0x45EB817F02C, 0xFFFFFE3099503945,
    0x18F8DCE1227, 0x26050EA6875, 0x298599C4BF0, 0xFFFFF8A356CE9E58,
    0xFFFFFED3C712CF36, 0xFFFFFE96846D630F, 0x58CB1CE3FF3, 0xFFFFFCCF182C2A63,
    0xFFFFFE57FDF3F1DE, 0xFFFFFA603F35F962, 0xFFFFFF7884570B57, 0x4897C4D9C1,
    0xFFFFFEB9355E5CB4, 0xDCEDF7D094, 0x3602E9CAC47, 0xFFFFFEE3667219D6,
    0xFFFFFDC326C9B063
]


v9 = [BitVec(f'{i}',64) for i in range(21)]

shr_sar = [0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x0, 0x0, 0x3ff, 0x0, 0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x0, 0x0, 0x0, 0x0, 0x3ff, 0x0, 0x0, 0x0, 0x3ff, 0x0, 0x0, 0x0, 0x3ff, 0x0, 0x3ff, 0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x0, 0x0, 0x0, 0x3ff, 0x0, 0x0, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x0, 0x0, 0x0, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x0, 0x3ff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3ff, 0x0, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x0, 0x3ff, 0x0, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x0, 0x0, 0x0, 0x3ff, 0x0, 0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x0, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x0, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x0, 0x0, 0x3ff, 0x3ff, 0x0, 0x0, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x0, 0x0, 0x0, 0x3ff, 0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x0, 0x0, 0x0, 0x0, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x0, 0x3ff, 0x0, 0x3ff, 0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x0, 0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x0, 0x0, 0x3ff, 0x0, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x0, 0x3ff, 0x0, 0x0, 0x3ff, 0x0, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x0, 0x3ff, 0x0, 0x0, 0x0, 0x0, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x0, 0x0, 0x0, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x0, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x0, 0x0, 0x3ff, 0x3ff, 0x0]
cnt = 0

random_value = xorshift128()
for i in range(21):

    value_after = BitVecVal(0, 64)

    for j in range(21):
        final = ctypes.c_ulong()
        final.value = (((int(random_value()) + shr_sar[cnt])  % 1024) - shr_sar[cnt])
        cnt += 1
        value_after += final.value * v9[j]

    s.add(value_after == v11[i])


if s.check() == sat:
    m = s.model()
    solution = [(m.evaluate(ai).as_long()) for ai in v9]
    print(solution)
else:
    print("nope")
```
Sinh ra các chuỗi con độ dài 4 từ chuỗi gốc và bruteforce
```python
import ctypes
import itertools

def generate_4char_strings(characters):
    result = [''.join(combination) for combination in itertools.product(characters, repeat=4)]
    return result

def sign_extend_32_to_64(value):
    if value & (1 << 31):
        extended_value = value | (0xffffffff << 32)
    else:
        extended_value = value
    return extended_value

def unsign_extend_64_to_32(value):
    lower_32_bits = value & 0xffffffff
    return lower_32_bits


def hash_64_fnv1a(a1, size):
    ulong_var = ctypes.c_ulong(0xCBF29CE484222325)
    for i in range(size, size + 4, 1):
        ulong_var.value = 0x100000001B3 * (a1[i] ^ ulong_var.value)
    tmp = ulong_var.value
    extended_value = unsign_extend_64_to_32(tmp)
    final = sign_extend_32_to_64(extended_value)
    return final

flag= b""

v9 = [18446744072877646971, 842869369, 18446744071836832300, 1874430657, 1643673264, 842869369, 18446744073484664935, 51900271, 1261422793, 1041996681, 1470239221, 18446744073176831124, 18446744072242323754, 18446744073420943119, 18446744071890218065, 18446744073352623759, 18446744073662195859, 18446744072184189399, 2055041019, 18446744072723039299, 72314917]

character_string = "!_acdefghilmnoprstuwy"

result_strings = generate_4char_strings(character_string)


for i in range(21):
   for string in result_strings:
        byte_array = bytearray(string.strip().encode())
        tmp = hash_64_fnv1a(byte_array,0)
        if tmp == v9[i]:
            flag+=byte_array
            break

print(b"TetCTF{" + flag + b"}")
```

***TetCTF{may_the_lanterns_of_the_lunar_new_year_light_up_your_path_to_success_and_happiness!!}***
> Đây không phải là một bài quá khó chủ yếu là tác giả khiến chúng ta suffer ở chỗ implement lại. Dẫu sao bài này giúp mình luyện code z3 và biết mình cần phải học kĩ lại các kiểu dữ liệu và cách biến đổi chúng...
