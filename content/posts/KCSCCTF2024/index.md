---
weight: 1
title: "KCSC CTF 2024"
date: 2024-05-14
lastmod: 2024-05-14
draft: false
author: "xPeters"
authorLink: "https://xpeters1337.github.io"
description: "Solutions for some reverse challenges in KCSC CTF 2024"
tags: ["RE", "2024"]
categories: ["Writeups"]

lightgallery: true

toc:
  enable: true
---
Solutions for some reverse challenges in KCSC CTF 2024

<!--more-->

# RE
Mình có xin được đề KCSC nên sẽ bắt đầu ngồi làm từ lúc giải bắt đầu cho tới khi end xem mình có thể làm được bao nhiêu câu.

## F@k3
Tải chương trình về và đọc thử hàm main.

```C=
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v4; // eax
  __int64 v5; // rdx
  __int64 v6; // r8
  char v8[256]; // [rsp+30h] [rbp-D18h] BYREF
  char Str[1024]; // [rsp+130h] [rbp-C18h] BYREF
  CHAR String2[1024]; // [rsp+530h] [rbp-818h] BYREF
  CHAR String1[1024]; // [rsp+930h] [rbp-418h] BYREF

  Str[0] = 0xDF;
  Str[1] = 69;
  Str[2] = 67;
  Str[3] = 49;
  Str[4] = -122;
  Str[5] = 38;
  Str[6] = 116;
  Str[7] = -97;
  Str[8] = -87;
  Str[9] = 118;
  Str[10] = -115;
  Str[11] = -86;
  Str[12] = -108;
  Str[13] = 116;
  Str[14] = -73;
  Str[15] = 46;
  Str[16] = -98;
  Str[17] = -94;
  Str[18] = 20;
  Str[19] = 5;
  Str[20] = 109;
  Str[21] = -87;
  Str[22] = -34;
  Str[23] = -89;
  Str[24] = 80;
  Str[25] = 57;
  Str[26] = 17;
  memset(&Str[27], 0, 0x3E5ui64);
  sub_1400010E0("[+] Input flag: ", argv, envp);
  sub_1400011B0("%s", String1);
  v3 = strlen(::Str);
  sub_140001880(v8, ::Str, v3);
  v4 = strlen(Str);
  RC4(v8, Str, v4, String2);
  if ( lstrcmpA(String1, String2) )
    sub_1400010E0("\nWrong!", v5, v6);
  else
    sub_1400010E0("Correct!", v5, v6);
  return 0;
}
```

Nhìn sơ qua thì có thể thấy nó nhận flag của chúng ta sau đó mã hóa RC4 chuỗi ``Str`` sau đó compare với flag bằng hàm ``lstrcmpA``. Và tất nhiên sẽ không có gì để nói nếu bài này lại dễ như vậy. Tuy nhiên khi thử debug thì mình nhận ra mình nhận fake flag. 

![image](https://github.com/ClownCS/clowncs.github.io/assets/90112096/fd1169fa-466a-49c3-8e6f-bb749a4ea93f)

Anti debug ? Lúc này mình xref trace ngược về những hàm mà call chuỗi ``Str`` tức key. 

```C
__int64 antidebug()
{
  if ( !*(_BYTE *)(qword_7FF7ACCD5670 + 2) )
  {
    Str[1] |= 1u;
    Str[2] |= 1u;
    Str[3] |= 1u;
    Str[4] |= 1u;
  }
  return 0i64;
}
```

Đặt breakpoint tại hàm check sau đó. Mình có được key đúng là ``FA++!``. Tưởng như thế đã là xong mình dùng key đó và giải mã mảng lúc đầu. Vẫn không ra ??? Và mình để ý rằng với input như nào thì output của hàm ``lstrcmpA`` luôn bằng 0 tức là hai chuỗi bằng nhau ?? 

Lúc này mình đã đi tới ngõ cụt. Mình liền đi xem các hàm còn lại xem có gì sus không.

```C
__int64 SUS()
{
  HMODULE ModuleHandleA; // [rsp+20h] [rbp-78h]
  unsigned int *i; // [rsp+28h] [rbp-70h]
  _QWORD *v3; // [rsp+30h] [rbp-68h]
  __int64 (__fastcall **lpAddress)(__int64, __int64); // [rsp+38h] [rbp-60h]
  DWORD flOldProtect; // [rsp+78h] [rbp-20h] BYREF

  ModuleHandleA = GetModuleHandleA(0i64);
  for ( i = (unsigned int *)((char *)ModuleHandleA
                           + (unsigned int)*(_QWORD *)((char *)ModuleHandleA + *((int *)ModuleHandleA + 15) + 144));
        i[3];
        i += 5 )
  {
    if ( LoadLibraryA((LPCSTR)ModuleHandleA + i[3]) )
    {
      v3 = (_QWORD *)((char *)ModuleHandleA + *i);
      lpAddress = (__int64 (__fastcall **)(__int64, __int64))((char *)ModuleHandleA + i[4]);
      while ( *v3 )
      {
        if ( !strcmp((const char *)ModuleHandleA + *v3 + 2, "lstrcmpA") )
        {
          flOldProtect = 0;
          VirtualProtect(lpAddress, 8ui64, 4u, &flOldProtect);
          *lpAddress = riel_func;
        }
        ++v3;
        ++lpAddress;
      }
    }
  }
  return 0i64;
}
```

Và rồi mình tìm được hàm này. Giải thích sơ qua hàm này sẽ load các thư viện và so sánh với ``lstrcmpA``. Nếu đúng gán ``lstrcmpA`` bằng hàm ``riel_func``.

```C
__int64 __fastcall riel_func(__int64 a1, __int64 a2)
{
  int i; // [rsp+20h] [rbp-128h]
  char Str[128]; // [rsp+30h] [rbp-118h] BYREF
  char v5[128]; // [rsp+B0h] [rbp-98h] BYREF

  qmemcpy(Str, "fM", 2);
  Str[2] = 12;
  Str[3] = -95;
  Str[4] = 86;
  Str[5] = 63;
  Str[6] = 43;
  Str[7] = -67;
  Str[8] = 78;
  Str[9] = 97;
  Str[10] = 106;
  Str[11] = -114;
  Str[12] = 73;
  Str[13] = 81;
  Str[14] = 61;
  Str[15] = -121;
  Str[16] = 114;
  Str[17] = 124;
  Str[18] = 54;
  Str[19] = -123;
  Str[20] = 69;
  Str[21] = 122;
  Str[22] = 104;
  Str[23] = -67;
  Str[24] = 75;
  Str[25] = 98;
  Str[26] = 62;
  Str[27] = -37;
  Str[28] = 114;
  Str[29] = 102;
  Str[30] = 58;
  Str[31] = -112;
  Str[32] = 72;
  Str[33] = 81;
  Str[34] = 1;
  Str[35] = -52;
  Str[36] = 115;
  Str[37] = 78;
  Str[38] = 31;
  Str[39] = -97;
  memset(&Str[40], 0, 0x58ui64);
  memset(v5, 0, sizeof(v5));
  for ( i = 0; i < strlen(Str); ++i )
    v5[i] = *(_BYTE *)(a2 + i % 4) ^ Str[i];
  return 0i64;
}
```
Lúc này thì mọi thứ đã rõ. Bản thân hàm này luôn ``return 0``. Đó là lí do vì sao khi debug nếu nhập input gì cũng correct. Hiểu được chương trình làm gì mình debug và lấy flag thôi.

![image](https://github.com/ClownCS/clowncs.github.io/assets/90112096/769169ce-20b7-4232-9601-5581f354a272)

Flag: ``KCSC{1t_co5ld_be_right7_fla9_here_^.^@@}``


## REXRUST

Một bài rev rust tuy nhiên thì cũng khá đơn giản. Chương trình đọc flag từ ``flag.txt``. Và sẽ mã hóa qua 4 phase sau đó ghi ra ``flag.enc``.


PHASE 1:

```C
void __cdecl revsrust::phase1::hff4818a749ae18af(_mut__u8_ data)
{
  core::ops::range::Range<usize> v1; // rdi
  usize v2; // [rsp+0h] [rbp-98h]
  usize v3; // [rsp+18h] [rbp-80h]
  u8 v4; // [rsp+27h] [rbp-71h]
  usize v5; // [rsp+28h] [rbp-70h]
  unsigned __int64 v6; // [rsp+30h] [rbp-68h]
  core::ops::range::Range<usize> v8; // [rsp+58h] [rbp-40h] BYREF
  core::option::Option<usize> v9; // [rsp+68h] [rbp-30h]
  _mut__u8_ v10; // [rsp+78h] [rbp-20h]
  __int64 v11; // [rsp+88h] [rbp-10h]
  u8 v12; // [rsp+97h] [rbp-1h]

  v10 = data;
  v1.end = data.length >> 1;
  v1.start = 0LL;
  v8 = _$LT$I$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$::into_iter::h8fa0f7e2a7257375(v1);
  while ( 1 )
  {
    v9 = core::iter::range::_$LT$impl$u20$core..iter..traits..iterator..Iterator$u20$for$u20$core..ops..range..Range$LT$A$GT$$GT$::next::h9b7c30fb7e58cb7b(&v8);
    if ( !*(_QWORD *)v9.gap0 )
      break;
    v6 = *(_QWORD *)&v9.gap0[8];
    v11 = *(_QWORD *)&v9.gap0[8];
    if ( *(_QWORD *)&v9.gap0[8] >= data.length )
      core::panicking::panic_bounds_check::h11601ba3567ad740();
    v4 = data.data_ptr[*(_QWORD *)&v9.gap0[8]];
    v12 = v4;
    v5 = data.length - 1;
    if ( !data.length )
      core::panicking::panic::hee69a8315e4031d6();
    v3 = v5 - *(_QWORD *)&v9.gap0[8];
    if ( v5 < *(_QWORD *)&v9.gap0[8] )
      core::panicking::panic::hee69a8315e4031d6();
    if ( v3 >= data.length )
      core::panicking::panic_bounds_check::h11601ba3567ad740();
    if ( *(_QWORD *)&v9.gap0[8] >= data.length )
      core::panicking::panic_bounds_check::h11601ba3567ad740();
    data.data_ptr[*(_QWORD *)&v9.gap0[8]] = data.data_ptr[v3];
    v2 = data.length - 1 - v6;
    if ( data.length - 1 < v6 )
      core::panicking::panic::hee69a8315e4031d6();
    if ( v2 >= data.length )
      core::panicking::panic_bounds_check::h11601ba3567ad740();
    data.data_ptr[v2] = v4;
  }
}
```

Phase 1 đơn giản là đảo ngược flag.


PHASE 2:

```C
void __cdecl revsrust::phase2::hf6a223748e1b24a0(_mut__u8_ data)
{
  u8 v1; // [rsp+17h] [rbp-71h]
  usize v2; // [rsp+48h] [rbp-40h]
  usize i; // [rsp+68h] [rbp-20h]

  for ( i = 0LL; i < data.length; i += 2LL )
  {
    v2 = i + 1;
    if ( i == -1LL )
      core::panicking::panic::hee69a8315e4031d6();
    if ( v2 >= data.length )
      core::panicking::panic_bounds_check::h11601ba3567ad740();
    if ( i + 1 >= data.length )
      core::panicking::panic_bounds_check::h11601ba3567ad740();
    if ( i >= data.length )
      core::panicking::panic_bounds_check::h11601ba3567ad740();
    v1 = data.data_ptr[i] & 0xF | data.data_ptr[i + 1] & 0xF0;
    data.data_ptr[i] = data.data_ptr[v2] & 0xF | data.data_ptr[i] & 0xF0;
    if ( i + 1 >= data.length )
      core::panicking::panic_bounds_check::h11601ba3567ad740();
    data.data_ptr[i + 1] = v1;
    if ( i >= 0xFFFFFFFFFFFFFFFELL )
      core::panicking::panic::hee69a8315e4031d6();
  }
}
```

Phase 2 có thể implement như sau

```python
for i in range(0, len(data), 2):
    data[i], data[i + 1] = (data[i + 1] & 0xf) | (data[i] & 0xf0), (data[i] & 0xf) | (data[i + 1] & 0xf0)
```

PHASE 3
```C
void __cdecl revsrust::phase3::h3b700fce28ff291d(_mut__u8_ data)
{
  u8 v1; // si
  u8 v2; // dl
  u8 v3; // [rsp+1Fh] [rbp-89h]
  usize v4; // [rsp+20h] [rbp-88h]
  u8 v5; // [rsp+2Fh] [rbp-79h]
  usize v6; // [rsp+30h] [rbp-78h]
  usize v7; // [rsp+38h] [rbp-70h]
  _mut__u8_ v8; // [rsp+40h] [rbp-68h]
  core::ops::range::Range<usize> v9; // [rsp+68h] [rbp-40h] BYREF
  core::option::Option<usize> v10; // [rsp+78h] [rbp-30h]
  _mut__u8_ v11; // [rsp+88h] [rbp-20h]
  __int64 v12; // [rsp+98h] [rbp-10h]
  u8 v13; // [rsp+A4h] [rbp-4h]
  u8 v14; // [rsp+A5h] [rbp-3h]
  u8 v15; // [rsp+A6h] [rbp-2h]
  u8 v16; // [rsp+A7h] [rbp-1h]

  v8 = data;
  v11 = data;
  if ( data.length < 2 )
    core::panicking::panic::hee69a8315e4031d6();
  data.data_ptr = 0LL;
  data.length -= 2LL;
  v9 = _$LT$I$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$::into_iter::h8fa0f7e2a7257375((core::ops::range::Range<usize>)data);
  while ( 1 )
  {
    v10 = core::iter::range::_$LT$impl$u20$core..iter..traits..iterator..Iterator$u20$for$u20$core..ops..range..Range$LT$A$GT$$GT$::next::h9b7c30fb7e58cb7b(&v9);
    if ( !*(_QWORD *)v10.gap0 )
      break;
    v7 = *(_QWORD *)&v10.gap0[8];
    v12 = *(_QWORD *)&v10.gap0[8];
    if ( *(_QWORD *)&v10.gap0[8] >= v8.length )
      core::panicking::panic_bounds_check::h11601ba3567ad740();
    v5 = v8.data_ptr[*(_QWORD *)&v10.gap0[8]];
    v6 = *(_QWORD *)&v10.gap0[8] + 2LL;
    if ( *(_QWORD *)&v10.gap0[8] >= 0xFFFFFFFFFFFFFFFELL )
      core::panicking::panic::hee69a8315e4031d6();
    if ( v6 >= v8.length )
      core::panicking::panic_bounds_check::h11601ba3567ad740();
    v1 = v8.data_ptr[v6];
    v15 = v8.data_ptr[*(_QWORD *)&v10.gap0[8]];
    v16 = v1;
    if ( *(_QWORD *)&v10.gap0[8] >= v8.length )
      core::panicking::panic_bounds_check::h11601ba3567ad740();
    v8.data_ptr[*(_QWORD *)&v10.gap0[8]] = v5 - v1;
    v4 = v7 + 2;
    if ( __CFADD__(v7, 2LL) )
      core::panicking::panic::hee69a8315e4031d6();
    if ( v4 >= v8.length )
      core::panicking::panic_bounds_check::h11601ba3567ad740();
    v3 = v8.data_ptr[v4];
    if ( v7 >= v8.length )
      core::panicking::panic_bounds_check::h11601ba3567ad740();
    v2 = v8.data_ptr[v7];
    v13 = v8.data_ptr[v4];
    v14 = v2;
    if ( v7 + 2 >= v8.length )
      core::panicking::panic_bounds_check::h11601ba3567ad740();
    v8.data_ptr[v7 + 2] = v3 - v2;
  }
}
```

Phase 3 thì

```python
for i in range(len(data) - 2):
    data[i] = (data[i] - data[i + 2]) & 0xff
    data[i + 2] = (data[i + 2] -  data[i]) & 0xff
```

PHASE 4:
```C
void __cdecl revsrust::phase4::h4b371456b6af0137(_mut__u8_ data)
{
  u8 *data_ptr; // [rsp+38h] [rbp-80h]
  u32 v2; // [rsp+4Ch] [rbp-6Ch]
  rand::rngs::thread::ThreadRng self; // [rsp+50h] [rbp-68h] BYREF
  core::ops::range::Range<usize> v4; // [rsp+58h] [rbp-60h]
  core::ops::range::Range<usize> v5; // [rsp+68h] [rbp-50h] BYREF
  core::option::Option<usize> v6; // [rsp+78h] [rbp-40h]
  _mut__u8_ v7; // [rsp+88h] [rbp-30h]
  u32 v8; // [rsp+ACh] [rbp-Ch]
  __int64 v9; // [rsp+B0h] [rbp-8h]

  data_ptr = data.data_ptr;
  v7 = data;
  self.rng.ptr.pointer = rand::rngs::thread::thread_rng::h616f5a4f3d25fa48().rng.ptr.pointer;
  v2 = rand::rng::Rng::gen::h3adc539b43e4e5da(&self);
  v8 = v2;
  v4.start = 0LL;
  v4.end = data.length;
  data.data_ptr = 0LL;
  v5 = _$LT$I$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$::into_iter::h8fa0f7e2a7257375((core::ops::range::Range<usize>)data);
  while ( 1 )
  {
    v6 = core::iter::range::_$LT$impl$u20$core..iter..traits..iterator..Iterator$u20$for$u20$core..ops..range..Range$LT$A$GT$$GT$::next::h9b7c30fb7e58cb7b(&v5);
    if ( !*(_QWORD *)v6.gap0 )
      break;
    v9 = *(_QWORD *)&v6.gap0[8];
    if ( *(_QWORD *)&v6.gap0[8] >= data.length )
      core::panicking::panic_bounds_check::h11601ba3567ad740();
    data_ptr[*(_QWORD *)&v6.gap0[8]] ^= HIBYTE(v2) ^ BYTE2(v2) ^ BYTE1(v2) ^ v2;
  }
  core::ptr::drop_in_place$LT$rand..rngs..thread..ThreadRng$GT$::h46c61e1ef1922a5a(&self);
}
```

Phase 4 thì chỉ là gen ra ramdom 32 bit number sau đó xor với flag. Có những dữ kiện như trên thì việc giải chỉ cần dùng z3.

```python
from z3 import *
with open("flag.enc", "rb") as f:
    cmp=f.read()

data = [BitVec(f'data_{i}', 32) for i in range(len(cmp))]

solver = Solver()

for i in range(len(data)):
    solver.add(data[i] > 32)
    solver.add(data[i] < 127)

flag = list(reversed(data))

for i in range(0, len(flag), 2):
    flag[i], flag[i + 1] = (flag[i + 1] & 0xf) | (flag[i] & 0xf0), (flag[i] & 0xf) | (flag[i + 1] & 0xf0)

for i in range(len(flag) - 2):
    flag[i] = (flag[i] - flag[i + 2]) & 0xff
    flag[i + 2] = (flag[i + 2] -  flag[i]) & 0xff


xor_key = BitVec('xor_key', 32)

for i in range(len(flag)):
    flag[i] ^= ((xor_key >> 0) & 0xff) ^ ((xor_key >> 8) & 0xff) ^ ((xor_key >> 16) & 0xff) ^ ((xor_key >> 24) & 0xff)


for i in range(len(cmp)):
    solver.add(flag[i] == cmp[i])

if solver.check() == sat:
    model = solver.model()
    original_data_values = [chr(model[data[i]].as_long()) for i in range(len(cmp))]
    print("".join(original_data_values))
```

Flag: ``KCSC{r3v3rs3_rust_1s_funny_4nd_34sy_227da29931351}``

## BEHIND THE SCENE
Trong suốt 8 tiếng diễn ra giải thì bài này đối với mình là tốn thời gian nhất không phải vì technique quá khó mà là do debug rất mỏi tay =))).

Tải file về và mở bằng IDA.

```C
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int i; // [esp+8h] [ebp-4h]

  sub_402E80();
  sub_401F20("Enter input: ", 71);
  sub_402E40("%s", (char)&unk_40775C);
  for ( i = 0; i < 1; ++i )
    ((void (*)(void))loc_401FF0)();
  Sleep(0x186A0u);
  return 0;
}
``` 

Có vẻ chỉ là một bài flag checker bình thường. Tuy nhiên hàm check flag đâu ? Mình qua ``Strings`` thử xem có tìm được gì không và mình bắt gặp những chuỗi base64. Sau khi decode và đổi tên lại mình có được như sau.

![image](https://github.com/ClownCS/clowncs.github.io/assets/90112096/0b4a88cc-86be-4e93-af51-c54259478436)

**DLL INJECTION**

Có thể thấy được chương trình này sử dụng ``KCSC.dll`` để check flag. Trace ngược lại chỗ gọi chuỗi này đặt breakpoint. Ta sẽ thấy lấy được file ``KCSC.dll`` ở path ``C:\Users\Peter\AppData\Local\Temp\KCSC.dll``

![image](https://github.com/ClownCS/clowncs.github.io/assets/90112096/a7bc3f40-a2be-4426-a5d2-04bb825a6cf9)

Tới đây có hai cách một là code chương trình nhỏ tương tác với file dll hoặc cứ debug tiếp. Ở đây mình chọn cách debug tiếp 

![image](https://github.com/ClownCS/clowncs.github.io/assets/90112096/c595335f-4383-40c8-a6b4-acde8eb9a80f)

``KCSC.dll``
```C
int __cdecl HelloWorld(char *Str1)
{
  char *v1; // eax
  int v2; // ecx
  const char *v3; // esi
  char v4; // al
  char v5; // bl
  unsigned int v6; // edi
  char v7; // bh
  bool v8; // zf
  int v9; // edx
  int v10; // eax
  int v11; // edx
  int v12; // edx
  int v13; // edx
  char v14; // al
  unsigned int v15; // edx
  char v16; // al
  bool v17; // cf
  int v18; // edx
  int v19; // eax
  int v20; // edx
  int v21; // edx
  int v22; // edx
  char v23; // al
  int v24; // edx
  int v25; // esi
  __int128 v27[2]; // [esp+4h] [ebp-618h] BYREF
  int v28; // [esp+24h] [ebp-5F8h]
  int v29; // [esp+28h] [ebp-5F4h]
  int v30; // [esp+2Ch] [ebp-5F0h]
  int v31; // [esp+30h] [ebp-5ECh]
  char v32; // [esp+37h] [ebp-5E5h]
  const char *v33; // [esp+38h] [ebp-5E4h]
  __int128 v34[69]; // [esp+3Ch] [ebp-5E0h]
  int v35; // [esp+48Ch] [ebp-190h]
  __int16 v36; // [esp+490h] [ebp-18Ch]
  char v37[390]; // [esp+492h] [ebp-18Ah] BYREF

  if ( strncmp(Str1, "de(RYpt3d_bu", 0xCu) )
    return 0;
  v34[0] = xmmword_10003360;
  v34[1] = xmmword_10003510;
  v34[2] = xmmword_10003430;
  v34[3] = xmmword_10003370;
  v34[4] = xmmword_100032B0;
  v34[5] = xmmword_100034A0;
  v34[6] = xmmword_100032D0;
  v34[7] = xmmword_10003200;
  v34[8] = xmmword_10003260;
  v34[9] = xmmword_10003520;
  v34[10] = xmmword_100033F0;
  v34[11] = xmmword_100032C0;
  v34[12] = xmmword_100032A0;
  v34[13] = xmmword_100031F0;
  v34[14] = xmmword_100034D0;
  v34[15] = xmmword_10003160;
  v34[16] = xmmword_100033B0;
  v34[17] = xmmword_10003140;
  v34[18] = xmmword_10003170;
  v34[19] = xmmword_10003490;
  v34[20] = xmmword_100030C0;
  v34[21] = xmmword_100033C0;
  v34[22] = xmmword_10003440;
  v34[23] = xmmword_10003110;
  v34[24] = xmmword_10003480;
  v34[25] = xmmword_10003320;
  v34[26] = xmmword_10003450;
  v34[27] = xmmword_10003500;
  v34[28] = xmmword_100034B0;
  v34[29] = xmmword_10003460;
  v34[30] = xmmword_100033D0;
  v34[31] = xmmword_100034E0;
  v34[32] = xmmword_10003130;
  v34[33] = xmmword_10003120;
  v34[34] = xmmword_10003230;
  v34[35] = xmmword_100033A0;
  v34[36] = xmmword_100030F0;
  v34[37] = xmmword_10003350;
  v34[38] = xmmword_10003190;
  v34[39] = xmmword_10003150;
  v34[40] = xmmword_100032E0;
  v34[41] = xmmword_10003210;
  v34[42] = xmmword_100031C0;
  v35 = 1691263788;
  v34[43] = xmmword_10003270;
  v36 = 20889;
  v34[44] = xmmword_10003330;
  v34[45] = xmmword_100033E0;
  v34[46] = xmmword_10003290;
  v34[47] = xmmword_100032F0;
  v34[48] = xmmword_100034F0;
  v34[49] = xmmword_10003240;
  v34[50] = xmmword_10003380;
  v34[51] = xmmword_100031D0;
  v34[52] = xmmword_10003340;
  v34[53] = xmmword_10003400;
  v34[54] = xmmword_10003220;
  v34[55] = xmmword_100031A0;
  v34[56] = xmmword_10003180;
  v34[57] = xmmword_10003420;
  v34[58] = xmmword_100034C0;
  v34[59] = xmmword_10003250;
  v34[60] = xmmword_10003280;
  v34[61] = xmmword_100031B0;
  v34[62] = xmmword_10003410;
  v34[63] = xmmword_10003300;
  v34[64] = xmmword_100030E0;
  v34[65] = xmmword_100030D0;
  v34[66] = xmmword_10003100;
  v34[67] = xmmword_10003390;
  v34[68] = xmmword_10003310;
  memset(v37, 0, sizeof(v37));
  v27[0] = xmmword_10003470;
  v27[1] = xmmword_100031E0;
  v28 = 698264022;
  v29 = 1219130212;
  v30 = -1161672993;
  v1 = strdup(Str1);
  v2 = 0;
  v3 = v1;
  v31 = 0;
  if ( strlen(v1) == 44 )
  {
    v32 = v4;
    v5 = v4;
    while ( 1 )
    {
      v6 = 0;
      if ( (v4 & 1) != 0 )
      {
        v7 = *v3;
        v33 = v3 + 1;
        v8 = &v3[strlen(v3) + 1] == v3 + 1;
        v9 = v31;
        if ( !v8 )
        {
          while ( 1 )
          {
            v10 = v9 / 3;
            v11 = v31++;
            v12 = v11 - 3 * v10;
            if ( !v12 )
            {
              v33 = v3 + 1;
              v15 = (unsigned int)&v3[strlen(v3) + 1];
              v16 = v7;
              if ( v6 != v15 - (_DWORD)(v3 + 1) - 1 )
                v16 = v3[v6 + 1];
              v3[v6] ^= v16 - *((_BYTE *)v34 + v2);
              goto LABEL_19;
            }
            v13 = v12 - 1;
            if ( !v13 )
              break;
            if ( v13 == 1 )
            {
              v33 = v3 + 1;
              if ( v6 == strlen(v3) - 1 )
                v3[v6] = v7 + *((_BYTE *)v34 + v2) - v3[v6];
              else
                v3[v6] = *((_BYTE *)v34 + v2) + v3[v6 + 1] - v3[v6];
LABEL_19:
              ++v2;
            }
            ++v6;
            v33 = v3 + 1;
            v17 = v6 < strlen(v3);
            v9 = v31;
            if ( !v17 )
              goto LABEL_40;
          }
          v33 = v3 + 1;
          if ( v6 == strlen(v3) - 1 )
            v14 = v7 ^ *((_BYTE *)v34 + v2);
          else
            v14 = *((_BYTE *)v34 + v2) ^ v3[v6 + 1];
          v3[v6] += v14;
          goto LABEL_19;
        }
        goto LABEL_40;
      }
      v33 = v3 + 1;
      v8 = &v3[strlen(v3) + 1] == v3 + 1;
      v18 = v31;
      if ( !v8 )
        break;
LABEL_40:
      v4 = v32 + 1;
      v32 = v4;
      if ( v4 >= 24 )
        goto LABEL_41;
    }
    while ( 1 )
    {
      v19 = v18 / 3;
      v20 = v31++;
      v21 = v20 - 3 * v19;
      if ( !v21 )
      {
        if ( !v6 )
        {
          v5 = *v3 ^ *((_BYTE *)v34 + v2);
          goto LABEL_36;
        }
        v23 = v3[v6] ^ (v3[v6 - 1] - *((_BYTE *)v34 + v2));
        goto LABEL_35;
      }
      v22 = v21 - 1;
      if ( !v22 )
        break;
      if ( v22 == 1 )
      {
        if ( !v6 )
        {
          v5 = *v3 - *((_BYTE *)v34 + v2);
LABEL_36:
          ++v2;
          goto LABEL_37;
        }
        v23 = v3[v6 - 1] + *((_BYTE *)v34 + v2) - v3[v6];
        goto LABEL_35;
      }
LABEL_37:
      if ( v6 == strlen(v3) - 1 )
        v3[v6] = v5;
      ++v6;
      v33 = v3 + 1;
      v17 = v6 < strlen(v3);
      v18 = v31;
      if ( !v17 )
        goto LABEL_40;
    }
    if ( !v6 )
    {
      v5 = *v3 + *((_BYTE *)v34 + v2);
      goto LABEL_36;
    }
    v23 = v3[v6] + (v3[v6 - 1] ^ *((_BYTE *)v34 + v2));
LABEL_35:
    v3[v6 - 1] = v5;
    v5 = v23;
    goto LABEL_36;
  }
LABEL_41:
  v24 = 0;
  v25 = v3 - (const char *)v27;
  while ( *((_BYTE *)v27 + v24 + v25) == *((_BYTE *)v27 + v24) )
  {
    if ( ++v24 >= 44 )
      return 1;
  }
  return 0;
}
```
Công đoạn tốn thời gian với mình nhất là rev và debug thuật toán này. Mình sẽ không giải thích quá nhiều. Đây là code reimplement của mình

```python
arr = [0xD1, 0x46, 0x40, 0x91, 0x2F, 0x64, 0x42, 0xD6, 0xE9, 0x2D, 
  0x19, 0x28, 0x10, 0xC8, 0x79, 0x88, 0x70, 0x32, 0xC6, 0x47, 
  0x35, 0x8D, 0x33, 0xE7, 0xB8, 0x70, 0xF2, 0x87, 0xDB, 0xDB, 
  0xDB, 0xFD, 0x26, 0x5B, 0xA6, 0xB5, 0xA5, 0xDF, 0x9A, 0x5B, 
  0x57, 0xB7, 0xB5, 0x7D, 0xC4, 0xAD, 0xE5, 0xC4, 0x72, 0x56, 
  0x58, 0x11, 0x2B, 0xAB, 0x86, 0x5A, 0x76, 0x8A, 0x67, 0x3E, 
  0x82, 0x8C, 0x74, 0x91, 0xC9, 0x66, 0x32, 0x1D, 0x3D, 0xD3, 
  0x33, 0x80, 0xD1, 0x10, 0xE7, 0xC7, 0x59, 0x4E, 0x31, 0x65, 
  0x91, 0xED, 0x66, 0x18, 0xBE, 0x9B, 0x0C, 0x26, 0x78, 0x75, 
  0xE7, 0x9E, 0x0C, 0xE8, 0xC2, 0xE6, 0xFC, 0x3C, 0x53, 0x8C, 
  0xC1, 0x0B, 0x2A, 0x12, 0x31, 0xAA, 0xA8, 0x32, 0x1B, 0x68, 
  0x90, 0x68, 0xF9, 0xBC, 0x73, 0xB7, 0x3E, 0xE4, 0x09, 0xAE, 
  0xC9, 0xE9, 0xCD, 0xAC, 0x8A, 0xC4, 0x8C, 0x4F, 0x0F, 0x68, 
  0xDA, 0xA8, 0x76, 0x2A, 0x8A, 0x6D, 0x53, 0x7F, 0xAC, 0xD5, 
  0xFE, 0x3C, 0x9F, 0x5C, 0x9A, 0x15, 0x22, 0x16, 0x7F, 0x1C, 
  0xCC, 0x92, 0x13, 0x51, 0xBF, 0xCF, 0x7C, 0x95, 0xCA, 0xFF, 
  0xCB, 0x59, 0xAF, 0xE9, 0x25, 0x0F, 0x4A, 0xA6, 0x4C, 0x1E, 
  0x7A, 0xD4, 0x2D, 0x58, 0xB0, 0xB0, 0x2A, 0xD6, 0xB5, 0x8C, 
  0xBF, 0x15, 0xA7, 0xB3, 0x77, 0xEB, 0xEA, 0x03, 0xD0, 0x4A, 
  0xC4, 0x65, 0x9B, 0xD4, 0xC1, 0xE8, 0xD8, 0xB6, 0x44, 0xE1, 
  0x5B, 0x1E, 0x99, 0x1C, 0x7E, 0xDF, 0xB5, 0x62, 0x27, 0xB2, 
  0x93, 0x5E, 0xFA, 0x39, 0x70, 0xBF, 0x58, 0x4F, 0x23, 0xAF, 
  0x6A, 0xA7, 0xAD, 0x48, 0xE8, 0x14, 0x19, 0x76, 0x20, 0x1D, 
  0x1D, 0x63, 0x03, 0x42, 0xF3, 0x1D, 0x63, 0x03, 0x42, 0xF3, 
  0x17, 0xAF, 0x87, 0xBC, 0x87, 0x26, 0xEC, 0x84, 0x84, 0xAC, 
  0x85, 0x4D, 0xFD, 0xF7, 0x09, 0x1F, 0x55, 0x86, 0x90, 0x21, 
  0x81, 0xC8, 0xC8, 0xDA, 0x75, 0x4D, 0xAF, 0x15, 0xAF, 0x4E, 
  0xEE, 0x99, 0x69, 0x39, 0xB0, 0x7A, 0xF6, 0xFB, 0x94, 0x16, 
  0x41, 0x48, 0xEC, 0x38, 0x28, 0xCD, 0x05, 0x1C, 0xC6, 0x49, 
  0xCE, 0x18, 0xE0, 0x1A, 0x6E, 0x66, 0xE4, 0xA4, 0xF2, 0x96, 
  0x4B, 0xEC, 0x74, 0x24, 0xA7, 0xEF, 0xDA, 0x64, 0x0A, 0x8A, 
  0xA3, 0x29, 0xD7, 0xD8, 0xB5, 0x0A, 0xC1, 0x42, 0x08, 0xDC, 
  0x46, 0x2B, 0x33, 0x22, 0xF3, 0xC9, 0xDF, 0x22, 0x69, 0xCD, 
  0x66, 0xCF, 0x04, 0x2A, 0x07, 0x01, 0x2F, 0x05, 0xB6, 0x07, 
  0xBA, 0xF8, 0xE5, 0x7E, 0x9B, 0x52, 0xFC, 0x91, 0x49, 0x86, 
  0x25, 0xA3, 0x2E, 0x64, 0x9E, 0xF1, 0xFC, 0x0F, 0x35, 0x21, 
  0x28, 0x6D, 0x48, 0x63, 0xF5, 0x11, 0xD5, 0xC8, 0xD4, 0xC1, 
  0xD0, 0x05, 0x9C, 0x5C, 0xAA, 0x49, 0x1B, 0xEF, 0x75, 0xBD, 
  0x6A, 0x90, 0xBD, 0x13, 0x76, 0x6E, 0xAD, 0xFF, 0xE2, 0xFB, 
  0x25, 0x39, 0xBA, 0x15, 0x2D, 0xC3, 0x61, 0x75, 0x8E, 0xD7, 
  0xAD, 0xD4, 0x68, 0xE4, 0x2C, 0x7C, 0xE8, 0xD1, 0x46, 0x74, 
  0x49, 0x5F, 0x26, 0x01, 0xED, 0x84, 0xCD, 0x71, 0x2D, 0x27, 
  0x73, 0xE9, 0xAB, 0x87, 0x09, 0x14, 0xF0, 0x51, 0x0E, 0xCC, 
  0x0C, 0xCE, 0xBF, 0xBB, 0x2F, 0x86, 0x09, 0x89, 0x46, 0xDA, 
  0x59, 0x3C, 0x4D, 0xC4, 0x88, 0x19, 0x63, 0xF9, 0xA0, 0x76, 
  0x26, 0x45, 0x2D, 0xA4, 0x66, 0x76, 0x5B, 0x71, 0x21, 0x13, 
  0x36, 0xC1, 0x77, 0xEC, 0xF4, 0xF3, 0xED, 0x11, 0xA8, 0xF0, 
  0x2B, 0x4B, 0xA8, 0xA2, 0xB7, 0x32, 0x53, 0x58, 0x6B, 0xD1, 
  0x27, 0xEB, 0xE2, 0x05, 0xE7, 0x1F, 0x58, 0x68, 0x07, 0x3C, 
  0x9D, 0x1E, 0x30, 0x22, 0xC9, 0xA5, 0x85, 0x41, 0xD4, 0xDE, 
  0x45, 0x28, 0xB1, 0x26, 0x61, 0x16, 0xBB, 0x58, 0xF8, 0xB2, 
  0xAD, 0xF4, 0xEC, 0x9B, 0x92, 0x13, 0x0D, 0x64, 0xDA, 0x8F, 
  0x08, 0xD4, 0xF1, 0xCC, 0xEA, 0x33, 0xC1, 0x1B, 0xC5, 0x6D, 
  0xF6, 0xAB, 0x4E, 0x1F, 0x3F, 0x67, 0x7A, 0xF0, 0xE0, 0xEF, 
  0x1D, 0xA5, 0x3A, 0x18, 0xDD, 0x3B, 0x3C, 0x65, 0xA5, 0x07, 
  0x5D, 0x89, 0x29, 0xAC, 0xEA, 0x8B, 0x23, 0x2B, 0xD3, 0x58, 
  0x3B, 0xBC, 0xCC, 0x69, 0x3B, 0x20, 0x64, 0xE4, 0xDB, 0xCD, 
  0x4E, 0x61, 0xAC, 0x17, 0xAF, 0x98, 0xEA, 0xEA, 0x87, 0xDF, 
  0xDD, 0x36, 0x41, 0xF3, 0x46, 0x0D, 0x6B, 0xC9, 0xB1, 0x71, 
  0xF6, 0x0E, 0xD9, 0x0C, 0x7E, 0xA1, 0x43, 0xCD, 0x83, 0x04, 
  0xA4, 0x6A, 0xA9, 0x60, 0x14, 0x4D, 0x77, 0x88, 0x04, 0xBF, 
  0x3E, 0x51, 0xAB, 0xBE, 0x09, 0x2C, 0xC0, 0xE6, 0x1F, 0xE5, 
  0x42, 0xFF, 0x15, 0x32, 0xFC, 0x4A, 0x22, 0x94, 0xF8, 0x66, 
  0xCA, 0x8D, 0x91, 0xAF, 0x8B, 0x61, 0xA4, 0x38, 0x17, 0x1E, 
  0xD4, 0x6F, 0x19, 0x50, 0xBF, 0x68, 0xB0, 0x12, 0x91, 0x2A, 
  0xC0, 0x83, 0x12, 0xBD, 0x0C, 0x69, 0xC9, 0x95, 0xAC, 0x6E, 
  0xCF, 0xCE, 0xAE, 0xB4, 0x58, 0x6F, 0xA4, 0x26, 0xB8, 0x9C, 
  0x40, 0x54, 0x5B, 0xB1, 0x48, 0x80, 0xD2, 0x62, 0xC3, 0xBD, 
  0x8A, 0xFA, 0x60, 0x10, 0x17, 0xB2, 0xE8, 0x35, 0x11, 0x64, 
  0x85, 0x70, 0x3C, 0x9A, 0x10, 0x2A, 0x12, 0xD9, 0x9F, 0xBE, 
  0x69, 0x35, 0x63, 0x5E, 0x4A, 0x2F, 0x11, 0x50, 0xE2, 0x34, 
  0x78, 0x0E, 0xBD, 0x85, 0x57, 0x15, 0xAE, 0x7C, 0x0B, 0x85, 
  0xFA, 0x15, 0xDF, 0xF9, 0xA3, 0x7E, 0x0C, 0x15, 0xD8, 0x82, 
  0x86, 0xDD, 0xFE, 0x51, 0xDA, 0xA9, 0x31, 0x22, 0xDA, 0xDB, 
  0x0B, 0xFF, 0xE7, 0x33, 0x63, 0xA3, 0xEA, 0xE2, 0x61, 0x35, 
  0x19, 0x62, 0x35, 0x87, 0x13, 0xDE, 0x35, 0x85, 0xFC, 0x18, 
  0x42, 0xBC, 0x12, 0x0E, 0x77, 0x61, 0x25, 0x6C, 0x97, 0x1A, 
  0x2D, 0x72, 0x41, 0x1B, 0x99, 0x49, 0xAE, 0x7E, 0x97, 0x66, 
  0x72, 0x58, 0x48, 0xF9, 0x25, 0x61, 0x81, 0x38, 0x83, 0x6A, 
  0x7E, 0x71, 0xA0, 0x02, 0x38, 0x50, 0x93, 0x6D, 0xD3, 0x59, 
  0xC0, 0xE3, 0x3E, 0xD7, 0xA7, 0xC4, 0x8B, 0x5A, 0x49, 0x0C, 
  0x1B, 0x0B, 0x75, 0xD7, 0x96, 0x97, 0x1D, 0x32, 0xF9, 0x11, 
  0x24, 0xB0, 0xEE, 0x4C, 0x91, 0x9D, 0x66, 0x51, 0xA9, 0x3C, 
  0x4C, 0x41, 0xB8, 0xE5, 0xE7, 0x9A, 0x22, 0xD4, 0xF3, 0x1D, 
  0xBB, 0x3A, 0x06, 0x88, 0x2C, 0x07, 0x27, 0x85, 0x74, 0x0C, 
  0x0A, 0xB3, 0x99, 0x05, 0x2A, 0x60, 0xDF, 0x02, 0x7B, 0x60, 
  0xBB, 0xE5, 0xC4, 0xB7, 0x30, 0x57, 0x14, 0x81, 0x6D, 0xE5, 
  0x88, 0xD1, 0x43, 0x13, 0x83, 0x32, 0x99, 0xBF, 0x4D, 0x56, 
  0xC6, 0xA1, 0x2F, 0x66, 0x53, 0x87, 0xB3, 0x93, 0x14, 0xA3, 
  0x5E, 0x5E, 0x87, 0x86, 0x79, 0x33, 0xEC, 0xF1, 0xC0, 0x64, 
  0xAB, 0xF2, 0x23, 0x4D, 0x40, 0xDC, 0xC3, 0xC4, 0x3F, 0x3A, 
  0x15, 0x28, 0xB7, 0x86, 0xE1, 0xD7, 0x15, 0xDA, 0x74, 0xC1, 
  0x05, 0x44, 0x46, 0x05, 0x28, 0x07, 0xD6, 0xBE, 0xAF, 0x5C, 
  0xA8, 0x3B, 0x0B, 0x14, 0x4E, 0x14, 0xCF, 0xB7, 0xF1, 0xAB, 
  0x7C, 0xF5, 0x63, 0xF0, 0xDC, 0xC2, 0x30, 0xDB, 0xC5, 0x2F, 
  0xB9, 0xC5, 0x57, 0x2A, 0xBF, 0x50, 0xF5, 0x39, 0x5D, 0x5A, 
  0x76, 0x63, 0x93, 0x7B, 0x61, 0x1D, 0x12, 0xE7, 0xC3, 0x0B, 
  0x61, 0xA9, 0xFB, 0x26, 0x15, 0x62, 0xBA, 0x32, 0x35, 0x4E, 
  0x09, 0xC2, 0x32, 0x31, 0xB2, 0x95, 0xD5, 0x8E, 0x51, 0xA2, 
  0xC3, 0x34, 0x1D, 0xB8, 0x61, 0x8D, 0x25, 0xB5, 0x97, 0x1D, 
  0x02, 0xFA, 0x55, 0xF9, 0xA3, 0xB1, 0x4A, 0xBA, 0x4C, 0xBE, 
  0x2B, 0x41, 0xA8, 0x71, 0x5F, 0x1B, 0xDD, 0x2C, 0x54, 0x76, 
  0x58, 0xC1, 0xDE, 0x6E, 0x2A, 0x7C, 0x5F, 0x93, 0xA1, 0x04, 
  0xDF, 0x45, 0x31, 0xE0, 0x11, 0x32, 0x47, 0x9B, 0x1C, 0x0D, 
  0x04, 0x92, 0x02, 0x44, 0x29, 0xB2, 0x11, 0x32, 0x7C, 0xD6, 
  0xF1, 0x2E, 0xBE, 0xB3, 0xA9, 0x04, 0xE9, 0xFA, 0x51, 0x0F, 
  0x28, 0x45, 0x3E, 0x83, 0x2B, 0x6F, 0x6D, 0xFA, 0xE8, 0x85, 
  0x52, 0x0F, 0x97, 0x93, 0x1D, 0xA3, 0xF0, 0xAB, 0x07, 0x3F, 
  0xB8, 0x3A, 0x30, 0xF8, 0x92, 0x2D, 0x04, 0x98, 0x27, 0x06, 
  0xA0, 0xC2, 0x5C, 0x1D, 0xBE, 0x08, 0x60, 0x1E, 0xD7, 0x3F, 
  0x77, 0x02, 0xDF, 0x77, 0x2C, 0xA3, 0xCE, 0x64, 0x99, 0x51]

stri = 'de(RYpt3d_buaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
inp = []
for c in stri:
    inp.append(ord(c))

i1 = i2 = 0
for i in range(24):
    if i % 2:
        inp0 = inp[0]
        for j in range(44):
            check1 = i2 % 3
            i2 += 1
            if check1 == 1:
                if j == 43:
                    inp[j] = (inp[j] + (inp0 ^ arr[i1])) & 0xff
                else:
                    inp[j] = (inp[j] + (arr[i1] ^ inp[j + 1])) & 0xff 
                i1 += 1
            elif check1 == 2:
                if j == 43:
                    inp[j] = (((inp0 + arr[i1]) & 0xff) - inp[j]) & 0xff
                else:
                    inp[j] = (((arr[i1] + inp[j + 1]) & 0xff) - inp[j]) & 0xff
                i1 += 1
            else:
                if j == 43:
                    inp[j] ^= ((inp0 - arr[i1]) & 0xff)
                else:
                    inp[j] ^= ((inp[j + 1] - arr[i1]) & 0xff)
                i1 += 1
        # print(inp)
    else:
        inp0 = inp[0]
        for k in range(44):
            check2 = i2 % 3
            i2 += 1
            if check2 == 1:
                if k:
                    tmp1 = (inp[k] + (arr[i1] ^ inp[k - 1])) & 0xff
                    inp[k - 1] = tmp2
                    tmp2 = tmp1
                else:
                    tmp2 = (arr[i1] + inp0) & 0xff 
                i1 += 1
            elif check2 == 2:
                if k:
                    tmp1 = (((arr[i1] + inp[k - 1]) & 0xff) - inp[k]) & 0xff
                    inp[k - 1] = tmp2
                    tmp2 = tmp1
                else:
                    tmp2 = (inp0 - arr[i1]) & 0xff
                i1 += 1
            else:
                if k:
                    tmp1 = inp[k] ^ (((inp[k - 1] - arr[i1])) & 0xff)
                    inp[k - 1] = tmp2
                    tmp2 = tmp1
                else:
                    tmp2 = arr[i1] ^ inp0
                i1 += 1
            if k == 43:
                inp[k] = tmp2
        # print(inp)



for i in inp:
    print(hex(i), end=', ')
```
Mảng compare là ``0F 21 CB 47 F6 B0 0E A0 69 51 5A 08 47 7E 21 D5 8E 31 F4 D6 AF D0 9A 40 03 2B D6 4C D7 58 D1 47 D6 A9 9E 29 64 73 AA 48 DF 46 C2 BA``. Implement được rồi thì z3 time =]]]. Đây là script giải của mình

```python
from z3 import *

cmp = [15, 33, 203, 71, 246, 176, 14, 160, 105, 81, 90, 8, 71, 126, 33, 213, 142, 49, 244, 214, 175, 208, 154, 64, 3, 43, 214, 76, 215, 88, 209, 71, 214, 169, 158, 41, 100, 115, 170, 72, 223, 70, 194, 186]

arr = [0xD1, 0x46, 0x40, 0x91, 0x2F, 0x64, 0x42, 0xD6, 0xE9, 0x2D, 
  0x19, 0x28, 0x10, 0xC8, 0x79, 0x88, 0x70, 0x32, 0xC6, 0x47, 
  0x35, 0x8D, 0x33, 0xE7, 0xB8, 0x70, 0xF2, 0x87, 0xDB, 0xDB, 
  0xDB, 0xFD, 0x26, 0x5B, 0xA6, 0xB5, 0xA5, 0xDF, 0x9A, 0x5B, 
  0x57, 0xB7, 0xB5, 0x7D, 0xC4, 0xAD, 0xE5, 0xC4, 0x72, 0x56, 
  0x58, 0x11, 0x2B, 0xAB, 0x86, 0x5A, 0x76, 0x8A, 0x67, 0x3E, 
  0x82, 0x8C, 0x74, 0x91, 0xC9, 0x66, 0x32, 0x1D, 0x3D, 0xD3, 
  0x33, 0x80, 0xD1, 0x10, 0xE7, 0xC7, 0x59, 0x4E, 0x31, 0x65, 
  0x91, 0xED, 0x66, 0x18, 0xBE, 0x9B, 0x0C, 0x26, 0x78, 0x75, 
  0xE7, 0x9E, 0x0C, 0xE8, 0xC2, 0xE6, 0xFC, 0x3C, 0x53, 0x8C, 
  0xC1, 0x0B, 0x2A, 0x12, 0x31, 0xAA, 0xA8, 0x32, 0x1B, 0x68, 
  0x90, 0x68, 0xF9, 0xBC, 0x73, 0xB7, 0x3E, 0xE4, 0x09, 0xAE, 
  0xC9, 0xE9, 0xCD, 0xAC, 0x8A, 0xC4, 0x8C, 0x4F, 0x0F, 0x68, 
  0xDA, 0xA8, 0x76, 0x2A, 0x8A, 0x6D, 0x53, 0x7F, 0xAC, 0xD5, 
  0xFE, 0x3C, 0x9F, 0x5C, 0x9A, 0x15, 0x22, 0x16, 0x7F, 0x1C, 
  0xCC, 0x92, 0x13, 0x51, 0xBF, 0xCF, 0x7C, 0x95, 0xCA, 0xFF, 
  0xCB, 0x59, 0xAF, 0xE9, 0x25, 0x0F, 0x4A, 0xA6, 0x4C, 0x1E, 
  0x7A, 0xD4, 0x2D, 0x58, 0xB0, 0xB0, 0x2A, 0xD6, 0xB5, 0x8C, 
  0xBF, 0x15, 0xA7, 0xB3, 0x77, 0xEB, 0xEA, 0x03, 0xD0, 0x4A, 
  0xC4, 0x65, 0x9B, 0xD4, 0xC1, 0xE8, 0xD8, 0xB6, 0x44, 0xE1, 
  0x5B, 0x1E, 0x99, 0x1C, 0x7E, 0xDF, 0xB5, 0x62, 0x27, 0xB2, 
  0x93, 0x5E, 0xFA, 0x39, 0x70, 0xBF, 0x58, 0x4F, 0x23, 0xAF, 
  0x6A, 0xA7, 0xAD, 0x48, 0xE8, 0x14, 0x19, 0x76, 0x20, 0x1D, 
  0x1D, 0x63, 0x03, 0x42, 0xF3, 0x1D, 0x63, 0x03, 0x42, 0xF3, 
  0x17, 0xAF, 0x87, 0xBC, 0x87, 0x26, 0xEC, 0x84, 0x84, 0xAC, 
  0x85, 0x4D, 0xFD, 0xF7, 0x09, 0x1F, 0x55, 0x86, 0x90, 0x21, 
  0x81, 0xC8, 0xC8, 0xDA, 0x75, 0x4D, 0xAF, 0x15, 0xAF, 0x4E, 
  0xEE, 0x99, 0x69, 0x39, 0xB0, 0x7A, 0xF6, 0xFB, 0x94, 0x16, 
  0x41, 0x48, 0xEC, 0x38, 0x28, 0xCD, 0x05, 0x1C, 0xC6, 0x49, 
  0xCE, 0x18, 0xE0, 0x1A, 0x6E, 0x66, 0xE4, 0xA4, 0xF2, 0x96, 
  0x4B, 0xEC, 0x74, 0x24, 0xA7, 0xEF, 0xDA, 0x64, 0x0A, 0x8A, 
  0xA3, 0x29, 0xD7, 0xD8, 0xB5, 0x0A, 0xC1, 0x42, 0x08, 0xDC, 
  0x46, 0x2B, 0x33, 0x22, 0xF3, 0xC9, 0xDF, 0x22, 0x69, 0xCD, 
  0x66, 0xCF, 0x04, 0x2A, 0x07, 0x01, 0x2F, 0x05, 0xB6, 0x07, 
  0xBA, 0xF8, 0xE5, 0x7E, 0x9B, 0x52, 0xFC, 0x91, 0x49, 0x86, 
  0x25, 0xA3, 0x2E, 0x64, 0x9E, 0xF1, 0xFC, 0x0F, 0x35, 0x21, 
  0x28, 0x6D, 0x48, 0x63, 0xF5, 0x11, 0xD5, 0xC8, 0xD4, 0xC1, 
  0xD0, 0x05, 0x9C, 0x5C, 0xAA, 0x49, 0x1B, 0xEF, 0x75, 0xBD, 
  0x6A, 0x90, 0xBD, 0x13, 0x76, 0x6E, 0xAD, 0xFF, 0xE2, 0xFB, 
  0x25, 0x39, 0xBA, 0x15, 0x2D, 0xC3, 0x61, 0x75, 0x8E, 0xD7, 
  0xAD, 0xD4, 0x68, 0xE4, 0x2C, 0x7C, 0xE8, 0xD1, 0x46, 0x74, 
  0x49, 0x5F, 0x26, 0x01, 0xED, 0x84, 0xCD, 0x71, 0x2D, 0x27, 
  0x73, 0xE9, 0xAB, 0x87, 0x09, 0x14, 0xF0, 0x51, 0x0E, 0xCC, 
  0x0C, 0xCE, 0xBF, 0xBB, 0x2F, 0x86, 0x09, 0x89, 0x46, 0xDA, 
  0x59, 0x3C, 0x4D, 0xC4, 0x88, 0x19, 0x63, 0xF9, 0xA0, 0x76, 
  0x26, 0x45, 0x2D, 0xA4, 0x66, 0x76, 0x5B, 0x71, 0x21, 0x13, 
  0x36, 0xC1, 0x77, 0xEC, 0xF4, 0xF3, 0xED, 0x11, 0xA8, 0xF0, 
  0x2B, 0x4B, 0xA8, 0xA2, 0xB7, 0x32, 0x53, 0x58, 0x6B, 0xD1, 
  0x27, 0xEB, 0xE2, 0x05, 0xE7, 0x1F, 0x58, 0x68, 0x07, 0x3C, 
  0x9D, 0x1E, 0x30, 0x22, 0xC9, 0xA5, 0x85, 0x41, 0xD4, 0xDE, 
  0x45, 0x28, 0xB1, 0x26, 0x61, 0x16, 0xBB, 0x58, 0xF8, 0xB2, 
  0xAD, 0xF4, 0xEC, 0x9B, 0x92, 0x13, 0x0D, 0x64, 0xDA, 0x8F, 
  0x08, 0xD4, 0xF1, 0xCC, 0xEA, 0x33, 0xC1, 0x1B, 0xC5, 0x6D, 
  0xF6, 0xAB, 0x4E, 0x1F, 0x3F, 0x67, 0x7A, 0xF0, 0xE0, 0xEF, 
  0x1D, 0xA5, 0x3A, 0x18, 0xDD, 0x3B, 0x3C, 0x65, 0xA5, 0x07, 
  0x5D, 0x89, 0x29, 0xAC, 0xEA, 0x8B, 0x23, 0x2B, 0xD3, 0x58, 
  0x3B, 0xBC, 0xCC, 0x69, 0x3B, 0x20, 0x64, 0xE4, 0xDB, 0xCD, 
  0x4E, 0x61, 0xAC, 0x17, 0xAF, 0x98, 0xEA, 0xEA, 0x87, 0xDF, 
  0xDD, 0x36, 0x41, 0xF3, 0x46, 0x0D, 0x6B, 0xC9, 0xB1, 0x71, 
  0xF6, 0x0E, 0xD9, 0x0C, 0x7E, 0xA1, 0x43, 0xCD, 0x83, 0x04, 
  0xA4, 0x6A, 0xA9, 0x60, 0x14, 0x4D, 0x77, 0x88, 0x04, 0xBF, 
  0x3E, 0x51, 0xAB, 0xBE, 0x09, 0x2C, 0xC0, 0xE6, 0x1F, 0xE5, 
  0x42, 0xFF, 0x15, 0x32, 0xFC, 0x4A, 0x22, 0x94, 0xF8, 0x66, 
  0xCA, 0x8D, 0x91, 0xAF, 0x8B, 0x61, 0xA4, 0x38, 0x17, 0x1E, 
  0xD4, 0x6F, 0x19, 0x50, 0xBF, 0x68, 0xB0, 0x12, 0x91, 0x2A, 
  0xC0, 0x83, 0x12, 0xBD, 0x0C, 0x69, 0xC9, 0x95, 0xAC, 0x6E, 
  0xCF, 0xCE, 0xAE, 0xB4, 0x58, 0x6F, 0xA4, 0x26, 0xB8, 0x9C, 
  0x40, 0x54, 0x5B, 0xB1, 0x48, 0x80, 0xD2, 0x62, 0xC3, 0xBD, 
  0x8A, 0xFA, 0x60, 0x10, 0x17, 0xB2, 0xE8, 0x35, 0x11, 0x64, 
  0x85, 0x70, 0x3C, 0x9A, 0x10, 0x2A, 0x12, 0xD9, 0x9F, 0xBE, 
  0x69, 0x35, 0x63, 0x5E, 0x4A, 0x2F, 0x11, 0x50, 0xE2, 0x34, 
  0x78, 0x0E, 0xBD, 0x85, 0x57, 0x15, 0xAE, 0x7C, 0x0B, 0x85, 
  0xFA, 0x15, 0xDF, 0xF9, 0xA3, 0x7E, 0x0C, 0x15, 0xD8, 0x82, 
  0x86, 0xDD, 0xFE, 0x51, 0xDA, 0xA9, 0x31, 0x22, 0xDA, 0xDB, 
  0x0B, 0xFF, 0xE7, 0x33, 0x63, 0xA3, 0xEA, 0xE2, 0x61, 0x35, 
  0x19, 0x62, 0x35, 0x87, 0x13, 0xDE, 0x35, 0x85, 0xFC, 0x18, 
  0x42, 0xBC, 0x12, 0x0E, 0x77, 0x61, 0x25, 0x6C, 0x97, 0x1A, 
  0x2D, 0x72, 0x41, 0x1B, 0x99, 0x49, 0xAE, 0x7E, 0x97, 0x66, 
  0x72, 0x58, 0x48, 0xF9, 0x25, 0x61, 0x81, 0x38, 0x83, 0x6A, 
  0x7E, 0x71, 0xA0, 0x02, 0x38, 0x50, 0x93, 0x6D, 0xD3, 0x59, 
  0xC0, 0xE3, 0x3E, 0xD7, 0xA7, 0xC4, 0x8B, 0x5A, 0x49, 0x0C, 
  0x1B, 0x0B, 0x75, 0xD7, 0x96, 0x97, 0x1D, 0x32, 0xF9, 0x11, 
  0x24, 0xB0, 0xEE, 0x4C, 0x91, 0x9D, 0x66, 0x51, 0xA9, 0x3C, 
  0x4C, 0x41, 0xB8, 0xE5, 0xE7, 0x9A, 0x22, 0xD4, 0xF3, 0x1D, 
  0xBB, 0x3A, 0x06, 0x88, 0x2C, 0x07, 0x27, 0x85, 0x74, 0x0C, 
  0x0A, 0xB3, 0x99, 0x05, 0x2A, 0x60, 0xDF, 0x02, 0x7B, 0x60, 
  0xBB, 0xE5, 0xC4, 0xB7, 0x30, 0x57, 0x14, 0x81, 0x6D, 0xE5, 
  0x88, 0xD1, 0x43, 0x13, 0x83, 0x32, 0x99, 0xBF, 0x4D, 0x56, 
  0xC6, 0xA1, 0x2F, 0x66, 0x53, 0x87, 0xB3, 0x93, 0x14, 0xA3, 
  0x5E, 0x5E, 0x87, 0x86, 0x79, 0x33, 0xEC, 0xF1, 0xC0, 0x64, 
  0xAB, 0xF2, 0x23, 0x4D, 0x40, 0xDC, 0xC3, 0xC4, 0x3F, 0x3A, 
  0x15, 0x28, 0xB7, 0x86, 0xE1, 0xD7, 0x15, 0xDA, 0x74, 0xC1, 
  0x05, 0x44, 0x46, 0x05, 0x28, 0x07, 0xD6, 0xBE, 0xAF, 0x5C, 
  0xA8, 0x3B, 0x0B, 0x14, 0x4E, 0x14, 0xCF, 0xB7, 0xF1, 0xAB, 
  0x7C, 0xF5, 0x63, 0xF0, 0xDC, 0xC2, 0x30, 0xDB, 0xC5, 0x2F, 
  0xB9, 0xC5, 0x57, 0x2A, 0xBF, 0x50, 0xF5, 0x39, 0x5D, 0x5A, 
  0x76, 0x63, 0x93, 0x7B, 0x61, 0x1D, 0x12, 0xE7, 0xC3, 0x0B, 
  0x61, 0xA9, 0xFB, 0x26, 0x15, 0x62, 0xBA, 0x32, 0x35, 0x4E, 
  0x09, 0xC2, 0x32, 0x31, 0xB2, 0x95, 0xD5, 0x8E, 0x51, 0xA2, 
  0xC3, 0x34, 0x1D, 0xB8, 0x61, 0x8D, 0x25, 0xB5, 0x97, 0x1D, 
  0x02, 0xFA, 0x55, 0xF9, 0xA3, 0xB1, 0x4A, 0xBA, 0x4C, 0xBE, 
  0x2B, 0x41, 0xA8, 0x71, 0x5F, 0x1B, 0xDD, 0x2C, 0x54, 0x76, 
  0x58, 0xC1, 0xDE, 0x6E, 0x2A, 0x7C, 0x5F, 0x93, 0xA1, 0x04, 
  0xDF, 0x45, 0x31, 0xE0, 0x11, 0x32, 0x47, 0x9B, 0x1C, 0x0D, 
  0x04, 0x92, 0x02, 0x44, 0x29, 0xB2, 0x11, 0x32, 0x7C, 0xD6, 
  0xF1, 0x2E, 0xBE, 0xB3, 0xA9, 0x04, 0xE9, 0xFA, 0x51, 0x0F, 
  0x28, 0x45, 0x3E, 0x83, 0x2B, 0x6F, 0x6D, 0xFA, 0xE8, 0x85, 
  0x52, 0x0F, 0x97, 0x93, 0x1D, 0xA3, 0xF0, 0xAB, 0x07, 0x3F, 
  0xB8, 0x3A, 0x30, 0xF8, 0x92, 0x2D, 0x04, 0x98, 0x27, 0x06, 
  0xA0, 0xC2, 0x5C, 0x1D, 0xBE, 0x08, 0x60, 0x1E, 0xD7, 0x3F, 
  0x77, 0x02, 0xDF, 0x77, 0x2C, 0xA3, 0xCE, 0x64, 0x99, 0x51]

data = [BitVec(f'data_{i}', 32) for i in range(44)]

solver = Solver()
know = [100, 101, 40, 82, 89 ,112, 116, 51, 100, 95 ,98, 117]

for i in range(12):
    solver.add(data[i] == know[i])

for i in range(12, len(data)):
    solver.add(data[i] > 32)
    solver.add(data[i] < 127)



inp = list(data)

i1 = i2 = 0
for i in range(24):
    if i % 2:
        inp0 = inp[0]
        for j in range(44):
            check1 = i2 % 3
            i2 += 1
            if check1 == 1:
                if j == 43:
                    inp[j] = (inp[j] + (inp0 ^ arr[i1])) & 0xff
                else:
                    inp[j] = (inp[j] + (arr[i1] ^ inp[j + 1])) & 0xff 
                i1 += 1
            elif check1 == 2:
                if j == 43:
                    inp[j] = (((inp0 + arr[i1]) & 0xff) - inp[j]) & 0xff
                else:
                    inp[j] = (((arr[i1] + inp[j + 1]) & 0xff) - inp[j]) & 0xff
                i1 += 1
            else:
                if j == 43:
                    inp[j] ^= ((inp0 - arr[i1]) & 0xff)
                else:
                    inp[j] ^= ((inp[j + 1] - arr[i1]) & 0xff)
                i1 += 1
        # print(inp)
    else:
        inp0 = inp[0]
        for k in range(44):
            check2 = i2 % 3
            i2 += 1
            if check2 == 1:
                if k:
                    tmp1 = (inp[k] + (arr[i1] ^ inp[k - 1])) & 0xff
                    inp[k - 1] = tmp2
                    tmp2 = tmp1
                else:
                    tmp2 = (arr[i1] + inp0) & 0xff 
                i1 += 1
            elif check2 == 2:
                if k:
                    tmp1 = (((arr[i1] + inp[k - 1]) & 0xff) - inp[k]) & 0xff
                    inp[k - 1] = tmp2
                    tmp2 = tmp1
                else:
                    tmp2 = (inp0 - arr[i1]) & 0xff
                i1 += 1
            else:
                if k:
                    tmp1 = inp[k] ^ (((inp[k - 1] - arr[i1])) & 0xff)
                    inp[k - 1] = tmp2
                    tmp2 = tmp1
                else:
                    tmp2 = arr[i1] ^ inp0
                i1 += 1
            if k == 43:
                inp[k] = tmp2


for i in range(len(cmp)):
    solver.add(inp[i] == cmp[i])

if solver.check() == sat:
    model = solver.model()
    original_data_values = [chr(model[data[i]].as_long()) for i in range(len(cmp))]
    print("".join(original_data_values))
```
p/s: Khi ngồi viết wu thì mình mới biết là ăn fake flag T_T

Tuy nhiên mình dính chưởng ngay fake flag :))). Mình ngồi rev lại xem có bỏ sót khúc nào không và yeah mình đã tìm thấy.

```C
int lmao()
{
  int v0; // eax
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v6; // [esp+10h] [ebp-270h]
  int v7; // [esp+14h] [ebp-26Ch]
  int v8; // [esp+18h] [ebp-268h]
  int v9; // [esp+1Ch] [ebp-264h]
  int v10; // [esp+20h] [ebp-260h]
  unsigned __int8 v11; // [esp+4Bh] [ebp-235h]
  int v12[139]; // [esp+4Ch] [ebp-234h] BYREF
  char v13[4]; // [esp+278h] [ebp-8h] BYREF

  v11 = 0;
  v0 = (*(int (__thiscall **)(int))(*(_DWORD *)dword_657790 + 40))(dword_657790);
  v1 = (*(int (__thiscall **)(int, int))(*(_DWORD *)dword_657790 + 40))(dword_657790, v0);
  v6 = sub_651770(v1);
  memset(v12, 0, sizeof(v12));
  v12[0] = 556;
  v10 = (*(int (__thiscall **)(int, int, _DWORD))(*(_DWORD *)dword_657790 + 44))(dword_657790, 2, 0);
  if ( (*(int (__thiscall **)(int, int, int *))(*(_DWORD *)dword_657790 + 48))(dword_657790, v10, v12) )
  {
    while ( 1 )
    {
      if ( v12[2] == v6 )
      {
        v2 = sub_652FE0("Y2hhbGwuZXhl", v13);   // chall.exe
        v9 = wcscmp((const unsigned __int16 *)&v12[9], (const unsigned __int16 *)sub_651860(v2));
        if ( v9 )
          v9 = v9 < 0 ? -1 : 1;
        if ( v9 )
        {
          v3 = sub_652FE0("Y21kLmV4ZQ==", v13); // cmd.exe
          v8 = wcscmp((const unsigned __int16 *)&v12[9], (const unsigned __int16 *)sub_651860(v3));
          if ( v8 )
            v8 = v8 < 0 ? -1 : 1;
          if ( v8 )
          {
            v4 = sub_652FE0("ZXhwbG9yZXIuZXhl", v13);// explorer.exe
            v7 = wcscmp((const unsigned __int16 *)&v12[9], (const unsigned __int16 *)sub_651860(v4));
            if ( v7 )
              v7 = v7 < 0 ? -1 : 1;
            if ( v7 )
              break;
          }
        }
      }
      if ( !(*(int (__thiscall **)(int, int, int *))(*(_DWORD *)dword_657790 + 52))(dword_657790, v10, v12) )
        goto LABEL_14;
    }
    v11 = 1;
  }
LABEL_14:
  if ( !v11 )
    sub_6518D0();
  (*(void (__thiscall **)(int, int))(*(_DWORD *)dword_657790 + 56))(dword_657790, v10);
  return v11;
}
```

Hàm này sẽ được call với mục đích check xem liệu file đang chạy có được chạy bằng ``cmd.exe`` không nếu không thì nó ko call hàm ``sub_6518d80`` hàm này tác động trực tiếp tới file ``KCSC.dll`` vậy thì bypass chỗ này khá đơn giản set breakpoint và cho nó call hàm đó là được. Sau đó ta sẽ có những giá trị đúng để thực hiện giải mã.

```python
from z3 import *

cmp = [65, 165, 195, 199, 154,  53, 126, 233,  32, 184, 
   76, 184,  70,  80,  41,  10, 172, 194,  25, 250, 
  171, 204, 228, 244, 146, 104, 254, 223, 214,  34, 
  170,  42,  61, 165,  58,  88,  40, 132,  53,  15, 
  230, 233,  49, 146]

arr = [0xD1, 0x46, 0x40, 0x91, 0x2F, 0x64, 0x42, 0xD6, 0xE9, 0x2D, 
  0x19, 0x28, 0x10, 0xC8, 0x79, 0x88, 0x70, 0x32, 0xC6, 0x47, 
  0x35, 0x8D, 0x33, 0xE7, 0xB8, 0x70, 0xF2, 0x87, 0xDB, 0xDB, 
  0xDB, 0xFD, 0x26, 0x5B, 0xA6, 0xB5, 0xA5, 0xDF, 0x9A, 0x5B, 
  0x57, 0xB7, 0xB5, 0x7D, 0xC4, 0xAD, 0xE5, 0xC4, 0x72, 0x56, 
  0x58, 0x11, 0x2B, 0xAB, 0x86, 0x5A, 0x76, 0x8A, 0x67, 0x3E, 
  0x82, 0x8C, 0x74, 0x91, 0xC9, 0x66, 0x32, 0x1D, 0x3D, 0xD3, 
  0x33, 0x80, 0xD1, 0x10, 0xE7, 0xC7, 0x59, 0x4E, 0x31, 0x65, 
  0x91, 0xED, 0x66, 0x18, 0xBE, 0x9B, 0x0C, 0x26, 0x78, 0x75, 
  0xE7, 0x9E, 0x0C, 0xE8, 0xC2, 0xE6, 0xFC, 0x3C, 0x53, 0x8C, 
  0xC1, 0x0B, 0x2A, 0x12, 0x31, 0xAA, 0xA8, 0x32, 0x1B, 0x68, 
  0x90, 0x68, 0xF9, 0xBC, 0x73, 0xB7, 0x3E, 0xE4, 0x09, 0xAE, 
  0xC9, 0xE9, 0xCD, 0xAC, 0x8A, 0xC4, 0x8C, 0x4F, 0x0F, 0x68, 
  0xDA, 0xA8, 0x76, 0x2A, 0x8A, 0x6D, 0x53, 0x7F, 0xAC, 0xD5, 
  0xFE, 0x3C, 0x9F, 0x5C, 0x9A, 0x15, 0x22, 0x16, 0x7F, 0x1C, 
  0xCC, 0x92, 0x13, 0x51, 0xBF, 0xCF, 0x7C, 0x95, 0xCA, 0xFF, 
  0xCB, 0x59, 0xAF, 0xE9, 0x25, 0x0F, 0x4A, 0xA6, 0x4C, 0x1E, 
  0x7A, 0xD4, 0x2D, 0x58, 0xB0, 0xB0, 0x2A, 0xD6, 0xB5, 0x8C, 
  0xBF, 0x15, 0xA7, 0xB3, 0x77, 0xEB, 0xEA, 0x03, 0xD0, 0x4A, 
  0xC4, 0x65, 0x9B, 0xD4, 0xC1, 0xE8, 0xD8, 0xB6, 0x44, 0xE1, 
  0x5B, 0x1E, 0x99, 0x1C, 0x7E, 0xDF, 0xB5, 0x62, 0x27, 0xB2, 
  0x93, 0x5E, 0xFA, 0x39, 0x70, 0xBF, 0x58, 0x4F, 0x23, 0xAF, 
  0x6A, 0xA7, 0xAD, 0x48, 0xE8, 0x14, 0x19, 0x76, 0x20, 0x1D, 
  0x1D, 0x63, 0x03, 0x42, 0xF3, 0x1D, 0x63, 0x03, 0x42, 0xF3, 
  0x17, 0xAF, 0x87, 0xBC, 0x87, 0x26, 0xEC, 0x84, 0x84, 0xAC, 
  0x85, 0x4D, 0xFD, 0xF7, 0x09, 0x1F, 0x55, 0x86, 0x90, 0x21, 
  0x81, 0xC8, 0xC8, 0xDA, 0x75, 0x4D, 0xAF, 0x15, 0xAF, 0x4E, 
  0xEE, 0x99, 0x69, 0x39, 0xB0, 0x7A, 0xF6, 0xFB, 0x94, 0x16, 
  0x41, 0x48, 0xEC, 0x38, 0x28, 0xCD, 0x05, 0x1C, 0xC6, 0x49, 
  0xCE, 0x18, 0xE0, 0x1A, 0x6E, 0x66, 0xE4, 0xA4, 0xF2, 0x96, 
  0x4B, 0xEC, 0x74, 0x24, 0xA7, 0xEF, 0xDA, 0x64, 0x0A, 0x8A, 
  0xA3, 0x29, 0xD7, 0xD8, 0xB5, 0x0A, 0xC1, 0x42, 0x08, 0xDC, 
  0x46, 0x2B, 0x33, 0x22, 0xF3, 0xC9, 0xDF, 0x22, 0x69, 0xCD, 
  0x66, 0xCF, 0x04, 0x2A, 0x07, 0x01, 0x2F, 0x05, 0xB6, 0x07, 
  0xBA, 0xF8, 0xE5, 0x7E, 0x9B, 0x52, 0xFC, 0x91, 0x49, 0x86, 
  0x25, 0xA3, 0x2E, 0x64, 0x9E, 0xF1, 0xFC, 0x0F, 0x35, 0x21, 
  0x28, 0x6D, 0x48, 0x63, 0xF5, 0x11, 0xD5, 0xC8, 0xD4, 0xC1, 
  0xD0, 0x05, 0x9C, 0x5C, 0xAA, 0x49, 0x1B, 0xEF, 0x75, 0xBD, 
  0x6A, 0x90, 0xBD, 0x13, 0x76, 0x6E, 0xAD, 0xFF, 0xE2, 0xFB, 
  0x25, 0x39, 0xBA, 0x15, 0x2D, 0xC3, 0x61, 0x75, 0x8E, 0xD7, 
  0xAD, 0xD4, 0x68, 0xE4, 0x2C, 0x7C, 0xE8, 0xD1, 0x46, 0x74, 
  0x49, 0x5F, 0x26, 0x01, 0xED, 0x84, 0xCD, 0x71, 0x2D, 0x27, 
  0x73, 0xE9, 0xAB, 0x87, 0x09, 0x14, 0xF0, 0x51, 0x0E, 0xCC, 
  0x0C, 0xCE, 0xBF, 0xBB, 0x2F, 0x86, 0x09, 0x89, 0x46, 0xDA, 
  0x59, 0x3C, 0x4D, 0xC4, 0x88, 0x19, 0x63, 0xF9, 0xA0, 0x76, 
  0x26, 0x45, 0x2D, 0xA4, 0x66, 0x76, 0x5B, 0x71, 0x21, 0x13, 
  0x36, 0xC1, 0x77, 0xEC, 0xF4, 0xF3, 0xED, 0x11, 0xA8, 0xF0, 
  0x2B, 0x4B, 0xA8, 0xA2, 0xB7, 0x32, 0x53, 0x58, 0x6B, 0xD1, 
  0x27, 0xEB, 0xE2, 0x05, 0xE7, 0x1F, 0x58, 0x68, 0x07, 0x3C, 
  0x9D, 0x1E, 0x30, 0x22, 0xC9, 0xA5, 0x85, 0x41, 0xD4, 0xDE, 
  0x45, 0x28, 0xB1, 0x26, 0x61, 0x16, 0xBB, 0x58, 0xF8, 0xB2, 
  0xAD, 0xF4, 0xEC, 0x9B, 0x92, 0x13, 0x0D, 0x64, 0xDA, 0x8F, 
  0x08, 0xD4, 0xF1, 0xCC, 0xEA, 0x33, 0xC1, 0x1B, 0xC5, 0x6D, 
  0xF6, 0xAB, 0x4E, 0x1F, 0x3F, 0x67, 0x7A, 0xF0, 0xE0, 0xEF, 
  0x1D, 0xA5, 0x3A, 0x18, 0xDD, 0x3B, 0x3C, 0x65, 0xA5, 0x07, 
  0x5D, 0x89, 0x29, 0xAC, 0xEA, 0x8B, 0x23, 0x2B, 0xD3, 0x58, 
  0x3B, 0xBC, 0xCC, 0x69, 0x3B, 0x20, 0x64, 0xE4, 0xDB, 0xCD, 
  0x4E, 0x61, 0xAC, 0x17, 0xAF, 0x98, 0xEA, 0xEA, 0x87, 0xDF, 
  0xDD, 0x36, 0x41, 0xF3, 0x46, 0x0D, 0x6B, 0xC9, 0xB1, 0x71, 
  0xF6, 0x0E, 0xD9, 0x0C, 0x7E, 0xA1, 0x43, 0xCD, 0x83, 0x04, 
  0xA4, 0x6A, 0xA9, 0x60, 0x14, 0x4D, 0x77, 0x88, 0x04, 0xBF, 
  0x3E, 0x51, 0xAB, 0xBE, 0x09, 0x2C, 0xC0, 0xE6, 0x1F, 0xE5, 
  0x42, 0xFF, 0x15, 0x32, 0xFC, 0x4A, 0x22, 0x94, 0xF8, 0x66, 
  0xCA, 0x8D, 0x91, 0xAF, 0x8B, 0x61, 0xA4, 0x38, 0x17, 0x1E, 
  0xD4, 0x6F, 0x19, 0x50, 0xBF, 0x68, 0xB0, 0x12, 0x91, 0x2A, 
  0xC0, 0x83, 0x12, 0xBD, 0x0C, 0x69, 0xC9, 0x95, 0xAC, 0x6E, 
  0xCF, 0xCE, 0xAE, 0xB4, 0x58, 0x6F, 0xA4, 0x26, 0xB8, 0x9C, 
  0x40, 0x54, 0x5B, 0xB1, 0x48, 0x80, 0xD2, 0x62, 0xC3, 0xBD, 
  0x8A, 0xFA, 0x60, 0x10, 0x17, 0xB2, 0xE8, 0x35, 0x11, 0x64, 
  0x85, 0x70, 0x3C, 0x9A, 0x10, 0x2A, 0x12, 0xD9, 0x9F, 0xBE, 
  0x69, 0x35, 0x63, 0x5E, 0x4A, 0x2F, 0x11, 0x50, 0xE2, 0x34, 
  0x78, 0x0E, 0xBD, 0x85, 0x57, 0x15, 0xAE, 0x7C, 0x0B, 0x85, 
  0xFA, 0x15, 0xDF, 0xF9, 0xA3, 0x7E, 0x0C, 0x15, 0xD8, 0x82, 
  0x86, 0xDD, 0xFE, 0x51, 0xDA, 0xA9, 0x31, 0x22, 0xDA, 0xDB, 
  0x0B, 0xFF, 0xE7, 0x33, 0x63, 0xA3, 0xEA, 0xE2, 0x61, 0x35, 
  0x19, 0x62, 0x35, 0x87, 0x13, 0xDE, 0x35, 0x85, 0xFC, 0x18, 
  0x42, 0xBC, 0x12, 0x0E, 0x77, 0x61, 0x25, 0x6C, 0x97, 0x1A, 
  0x2D, 0x72, 0x41, 0x1B, 0x99, 0x49, 0xAE, 0x7E, 0x97, 0x66, 
  0x72, 0x58, 0x48, 0xF9, 0x25, 0x61, 0x81, 0x38, 0x83, 0x6A, 
  0x7E, 0x71, 0xA0, 0x02, 0x38, 0x50, 0x93, 0x6D, 0xD3, 0x59, 
  0xC0, 0xE3, 0x3E, 0xD7, 0xA7, 0xC4, 0x8B, 0x5A, 0x49, 0x0C, 
  0x1B, 0x0B, 0x75, 0xD7, 0x96, 0x97, 0x1D, 0x32, 0xF9, 0x11, 
  0x24, 0xB0, 0xEE, 0x4C, 0x91, 0x9D, 0x66, 0x51, 0xA9, 0x3C, 
  0x4C, 0x41, 0xB8, 0xE5, 0xE7, 0x9A, 0x22, 0xD4, 0xF3, 0x1D, 
  0xBB, 0x3A, 0x06, 0x88, 0x2C, 0x07, 0x27, 0x85, 0x74, 0x0C, 
  0x0A, 0xB3, 0x99, 0x05, 0x2A, 0x60, 0xDF, 0x02, 0x7B, 0x60, 
  0xBB, 0xE5, 0xC4, 0xB7, 0x30, 0x57, 0x14, 0x81, 0x6D, 0xE5, 
  0x88, 0xD1, 0x43, 0x13, 0x83, 0x32, 0x99, 0xBF, 0x4D, 0x56, 
  0xC6, 0xA1, 0x2F, 0x66, 0x53, 0x87, 0xB3, 0x93, 0x14, 0xA3, 
  0x5E, 0x5E, 0x87, 0x86, 0x79, 0x33, 0xEC, 0xF1, 0xC0, 0x64, 
  0xAB, 0xF2, 0x23, 0x4D, 0x40, 0xDC, 0xC3, 0xC4, 0x3F, 0x3A, 
  0x15, 0x28, 0xB7, 0x86, 0xE1, 0xD7, 0x15, 0xDA, 0x74, 0xC1, 
  0x05, 0x44, 0x46, 0x05, 0x28, 0x07, 0xD6, 0xBE, 0xAF, 0x5C, 
  0xA8, 0x3B, 0x0B, 0x14, 0x4E, 0x14, 0xCF, 0xB7, 0xF1, 0xAB, 
  0x7C, 0xF5, 0x63, 0xF0, 0xDC, 0xC2, 0x30, 0xDB, 0xC5, 0x2F, 
  0xB9, 0xC5, 0x57, 0x2A, 0xBF, 0x50, 0xF5, 0x39, 0x5D, 0x5A, 
  0x76, 0x63, 0x93, 0x7B, 0x61, 0x1D, 0x12, 0xE7, 0xC3, 0x0B, 
  0x61, 0xA9, 0xFB, 0x26, 0x15, 0x62, 0xBA, 0x32, 0x35, 0x4E, 
  0x09, 0xC2, 0x32, 0x31, 0xB2, 0x95, 0xD5, 0x8E, 0x51, 0xA2, 
  0xC3, 0x34, 0x1D, 0xB8, 0x61, 0x8D, 0x25, 0xB5, 0x97, 0x1D, 
  0x02, 0xFA, 0x55, 0xF9, 0xA3, 0xB1, 0x4A, 0xBA, 0x4C, 0xBE, 
  0x2B, 0x41, 0xA8, 0x71, 0x5F, 0x1B, 0xDD, 0x2C, 0x54, 0x76, 
  0x58, 0xC1, 0xDE, 0x6E, 0x2A, 0x7C, 0x5F, 0x93, 0xA1, 0x04, 
  0xDF, 0x45, 0x31, 0xE0, 0x11, 0x32, 0x47, 0x9B, 0x1C, 0x0D, 
  0x04, 0x92, 0x02, 0x44, 0x29, 0xB2, 0x11, 0x32, 0x7C, 0xD6, 
  0xF1, 0x2E, 0xBE, 0xB3, 0xA9, 0x04, 0xE9, 0xFA, 0x51, 0x0F, 
  0x28, 0x45, 0x3E, 0x83, 0x2B, 0x6F, 0x6D, 0xFA, 0xE8, 0x85, 
  0x52, 0x0F, 0x97, 0x93, 0x1D, 0xA3, 0xF0, 0xAB, 0x07, 0x3F, 
  0xB8, 0x3A, 0x30, 0xF8, 0x92, 0x2D, 0x04, 0x98, 0x27, 0x06, 
  0xA0, 0xC2, 0x5C, 0x1D, 0xBE, 0x08, 0x60, 0x1E, 0xD7, 0x3F, 
  0x77, 0x02, 0xDF, 0x77, 0x2C, 0xA3, 0xCE, 0x64, 0x99, 0x51]

data = [BitVec(f'data_{i}', 32) for i in range(44)]

solver = Solver()
know = [75, 67, 83, 67, 123, 107, 99, 115, 99, 99, 116, 102]

for i in range(12):
    solver.add(data[i] == know[i])

for i in range(12, len(data)):
    solver.add(data[i] > 32)
    solver.add(data[i] < 127)



inp = list(data)

i1 = i2 = 0
for i in range(24):
    if i % 2:
        inp0 = inp[0]
        for j in range(44):
            check1 = i2 % 3
            i2 += 1
            if check1 == 1:
                if j == 43:
                    inp[j] = (inp[j] + (inp0 ^ arr[i1])) & 0xff
                else:
                    inp[j] = (inp[j] + (arr[i1] ^ inp[j + 1])) & 0xff 
                i1 += 1
            elif check1 == 2:
                if j == 43:
                    inp[j] = (((inp0 + arr[i1]) & 0xff) - inp[j]) & 0xff
                else:
                    inp[j] = (((arr[i1] + inp[j + 1]) & 0xff) - inp[j]) & 0xff
                i1 += 1
            else:
                if j == 43:
                    inp[j] ^= ((inp0 - arr[i1]) & 0xff)
                else:
                    inp[j] ^= ((inp[j + 1] - arr[i1]) & 0xff)
                i1 += 1
        # print(inp)
    else:
        inp0 = inp[0]
        for k in range(44):
            check2 = i2 % 3
            i2 += 1
            if check2 == 1:
                if k:
                    tmp1 = (inp[k] + (arr[i1] ^ inp[k - 1])) & 0xff
                    inp[k - 1] = tmp2
                    tmp2 = tmp1
                else:
                    tmp2 = (arr[i1] + inp0) & 0xff 
                i1 += 1
            elif check2 == 2:
                if k:
                    tmp1 = (((arr[i1] + inp[k - 1]) & 0xff) - inp[k]) & 0xff
                    inp[k - 1] = tmp2
                    tmp2 = tmp1
                else:
                    tmp2 = (inp0 - arr[i1]) & 0xff
                i1 += 1
            else:
                if k:
                    tmp1 = inp[k] ^ (((inp[k - 1] - arr[i1])) & 0xff)
                    inp[k - 1] = tmp2
                    tmp2 = tmp1
                else:
                    tmp2 = arr[i1] ^ inp0
                i1 += 1
            if k == 43:
                inp[k] = tmp2


for i in range(len(cmp)):
    solver.add(inp[i] == cmp[i])

while solver.check() == sat:
    model = solver.model()
    original_data_values = [chr(model[data[i]].as_long()) for i in range(len(cmp))]
    print("".join(original_data_values))
```

Flag: ``KCSC{kcscctf_2024_1_l0v3_y0u_@RSeqTke3a5v3D}``  

> Cảm ơn author của KCSC đã ra những bài thú vị <3 

